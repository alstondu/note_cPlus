# E15 - E21

*2024/07/13*

## E15 Variadic Templates example 1

Variadic 既指参数数量可变，也指参数类型可变

```c++
template <typename T, typename... Types>
void func(const T& firstArg, Types&... args){
	// 处理 firstArg
	func(args...); // 递归分离参数 pack
}
```
example 1 见 [E2 Variadic Templates](https://github.com/alstondu/note_cPlus/blob/main/E1%20%26%26%20E2.md)

## E16 Variadic Templates example 2

使用 variadic template 重写 printf()

```c++
template<typename T, typename... Args>
void printf(const char* s, T value, Args... args){
	while (*s){ // 遍历输入的字符串
		if (*s == '%'){ // 一旦检测到 '%'
			std::cout << value; // 打印出分解出的第一个参数
			printf(++s, args...); // 递归传入剩下的字符串和参数 pack
			return;
		}
		std::cout << *s++;
	}
	throw std::logic_error("extra arguments provided to printf")
}

// 递归到最后已经没有字符串以外的参数时调用这个
void printf(cons char* s){
	while (*s){
		// 如果参数已经没了，但是还检测到了 '%', 说明字符串里的 '%' 数量与参数数量不对等，丢出异常
		if (*s == '%'){
			throw std::runtime_error("invalid format string: missing arguments");
		}
		std::cout << *s++;
	}
}
```
对给 cout 的对象的类可能需要对 `<<` 重载。上面字符串其实没什么用了，只是为了模拟 C 语言中的 printf 而已。

**Todo：**
*2024/07/14*
## E17 Variadic Templates example 3
## E18 Variadic Templates example 4
## E19 Variadic Templates example 5
## E20 Variadic Templates example 6
## E21 Variadic Templates example 7