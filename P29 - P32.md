# P29 - P32

*2024/07/06*

## P29 复合&继承关系下的构造和析构

1. 继承：子类在外，父类在内

	构造由内而外，（编译器）先调用父类构造函数（内），再调用子类构造函数（外）。
	
	析构由外而内，（编译器）先执行子类的析构函数（外），再执行父类的析构函数（内）。
	
2. 复合：container 在外，component 在内

	构造由内而外，（编译器）先调用 component 构造函数（内），再调用 container 构造函数（外）。
	
	析构由外而内，（编译器）先执行 container 的析构函数（外），再执行component 的析构函数（内）。

3. 继承 + 复合：子类中有 component

	构造由内而外：base -> component -> derived
	
	析构由外而内：derived -> component -> base
	
	*base 和 component 的构造和析构顺序可能 vary from 编译器*
	
## P30 对象模型（Object Model）

1. 当一个类中有虚函数，其中就会多一根指针（无论多少个虚函数都是一根指针），这根指针叫虚指针（virtual pointer）。

2. 父类有虚函数，子类会继承其调用权，因此一定也有一根指针。

3. 每个类中的 vptr 指向一个表格，叫虚表（virtual table），表中是一些指针，指向虚函数（就是说表中存的是各个虚函数的地址）。直接继承下来的虚函数地址不变，被重写的虚函数则有自己单独的地址。
4. 现在有三个类， C 继承 B，B 继承 A。可以创建一个容器 List 存放 A类型的指针：```List<A*> myList;```, 因为 A 是父类，因此该容器内的指针也可以指向 B 和 C的对象，这个叫 **up-cast**。因为三个类的对象大小不同，但容器内的元素大小必须相同，因此储存指针，分别指向对象。

	B，C 可以分别重写 A 的虚函数，调用相同的函数时到底调用哪一个，取决于当前指针指向的对象类型。这种操作叫函数的动态绑定。
	
	*（相比之下，在 C 语言中则是静态绑定，调用的函数地址是固定的，判断调用什么函数要先 if else 去判断当前对象类型，如果新增加一个子类，则要再加一个 if else。）*
	
	动态绑定（虚机制）条件：
	1. 通过指针调用
	2. 指针 up-cast
	3. 调用的是虚函数
	
	虚函数的这种用法被称为多态。
	
## P31 this pointer

1. 通过一个对象调用一个函数，这个对象的地址就是 this

2. 所有成员函数都有一个隐藏的 this 
	
## P32 Dynamic Building

通过对象调用虚函数是静态绑定，编译器底层直接 call 函数地址（汇编语言）。

通过指针调用虚函数的时候是动态绑定，通过指针找到对象地址，找到里面的 vptr，找到 vtbl，然后传入传入自身对象的 this 去调用。


	

	